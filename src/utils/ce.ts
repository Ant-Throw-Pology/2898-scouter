import { makeid, mixin } from ".";

type ElementConversions = {
    "a": HTMLAnchorElement;
    "abbr": HTMLElement;
    "address": HTMLElement;
    "area": HTMLAreaElement;
    "article": HTMLElement;
    "aside": HTMLElement;
    "audio": HTMLAudioElement;
    "b": HTMLElement;
    "base": HTMLBaseElement;
    "bdi": HTMLElement;
    "bdo": HTMLElement;
    "blockquote": HTMLQuoteElement;
    "body": HTMLBodyElement;
    "br": HTMLBRElement;
    "button": HTMLButtonElement;
    "canvas": HTMLCanvasElement;
    "caption": HTMLTableCaptionElement;
    "cite": HTMLElement;
    "code": HTMLElement;
    "col": HTMLTableColElement;
    "colgroup": HTMLTableColElement;
    "data": HTMLDataElement;
    "datalist": HTMLDataListElement;
    "dd": HTMLElement;
    "del": HTMLModElement;
    "details": HTMLDetailsElement;
    "dfn": HTMLElement;
    "dialog": HTMLDialogElement;
    "div": HTMLDivElement;
    "dl": HTMLDListElement;
    "dt": HTMLElement;
    "em": HTMLElement;
    "embed": HTMLEmbedElement;
    "fieldset": HTMLFieldSetElement;
    "figcaption": HTMLElement;
    "figure": HTMLElement;
    "footer": HTMLElement;
    "form": HTMLFormElement;
    "h1": HTMLHeadingElement;
    "h2": HTMLHeadingElement;
    "h3": HTMLHeadingElement;
    "h4": HTMLHeadingElement;
    "h5": HTMLHeadingElement;
    "h6": HTMLHeadingElement;
    "head": HTMLHeadElement;
    "header": HTMLElement;
    "hgroup": HTMLElement;
    "hr": HTMLHRElement;
    "html": HTMLHtmlElement;
    "i": HTMLElement;
    "iframe": HTMLIFrameElement;
    "img": HTMLImageElement;
    "input": HTMLInputElement;
    "ins": HTMLModElement;
    "kbd": HTMLElement;
    "label": HTMLLabelElement;
    "legend": HTMLLegendElement;
    "li": HTMLLIElement;
    "link": HTMLLinkElement;
    "main": HTMLElement;
    "map": HTMLMapElement;
    "mark": HTMLElement;
    "menu": HTMLMenuElement;
    "meta": HTMLMetaElement;
    "meter": HTMLMeterElement;
    "nav": HTMLElement;
    "noscript": HTMLElement;
    "object": HTMLObjectElement;
    "ol": HTMLOListElement;
    "optgroup": HTMLOptGroupElement;
    "option": HTMLOptionElement;
    "output": HTMLOutputElement;
    "p": HTMLParagraphElement;
    "picture": HTMLPictureElement;
    "portal": HTMLUnknownElement;
    "pre": HTMLPreElement;
    "progress": HTMLProgressElement;
    "q": HTMLQuoteElement;
    "rp": HTMLElement;
    "rt": HTMLElement;
    "ruby": HTMLElement;
    "s": HTMLElement;
    "samp": HTMLElement;
    "script": HTMLScriptElement;
    "search": HTMLElement;
    "section": HTMLElement;
    "select": HTMLSelectElement;
    "slot": HTMLSlotElement;
    "small": HTMLElement;
    "source": HTMLSourceElement;
    "span": HTMLSpanElement;
    "strong": HTMLElement;
    "style": HTMLStyleElement;
    "sub": HTMLElement;
    "summary": HTMLElement;
    "sup": HTMLElement;
    "table": HTMLTableElement;
    "tbody": HTMLTableSectionElement;
    "td": HTMLTableCellElement;
    "template": HTMLTemplateElement;
    "textarea": HTMLTextAreaElement;
    "tfoot": HTMLTableSectionElement;
    "th": HTMLTableCellElement;
    "thead": HTMLTableSectionElement;
    "time": HTMLTimeElement;
    "title": HTMLTitleElement;
    "tr": HTMLTableRowElement;
    "track": HTMLTrackElement;
    "u": HTMLElement;
    "ul": HTMLUListElement;
    "var": HTMLElement;
    "video": HTMLVideoElement;
    "wbr": HTMLElement;
    "html:a": HTMLAnchorElement;
    "html:abbr": HTMLElement;
    "html:address": HTMLElement;
    "html:area": HTMLAreaElement;
    "html:article": HTMLElement;
    "html:aside": HTMLElement;
    "html:audio": HTMLAudioElement;
    "html:b": HTMLElement;
    "html:base": HTMLBaseElement;
    "html:bdi": HTMLElement;
    "html:bdo": HTMLElement;
    "html:blockquote": HTMLQuoteElement;
    "html:body": HTMLBodyElement;
    "html:br": HTMLBRElement;
    "html:button": HTMLButtonElement;
    "html:canvas": HTMLCanvasElement;
    "html:caption": HTMLTableCaptionElement;
    "html:cite": HTMLElement;
    "html:code": HTMLElement;
    "html:col": HTMLTableColElement;
    "html:colgroup": HTMLTableColElement;
    "html:data": HTMLDataElement;
    "html:datalist": HTMLDataListElement;
    "html:dd": HTMLElement;
    "html:del": HTMLModElement;
    "html:details": HTMLDetailsElement;
    "html:dfn": HTMLElement;
    "html:dialog": HTMLDialogElement;
    "html:div": HTMLDivElement;
    "html:dl": HTMLDListElement;
    "html:dt": HTMLElement;
    "html:em": HTMLElement;
    "html:embed": HTMLEmbedElement;
    "html:fieldset": HTMLFieldSetElement;
    "html:figcaption": HTMLElement;
    "html:figure": HTMLElement;
    "html:footer": HTMLElement;
    "html:form": HTMLFormElement;
    "html:h1": HTMLHeadingElement;
    "html:h2": HTMLHeadingElement;
    "html:h3": HTMLHeadingElement;
    "html:h4": HTMLHeadingElement;
    "html:h5": HTMLHeadingElement;
    "html:h6": HTMLHeadingElement;
    "html:head": HTMLHeadElement;
    "html:header": HTMLElement;
    "html:hgroup": HTMLElement;
    "html:hr": HTMLHRElement;
    "html:html": HTMLHtmlElement;
    "html:i": HTMLElement;
    "html:iframe": HTMLIFrameElement;
    "html:img": HTMLImageElement;
    "html:input": HTMLInputElement;
    "html:ins": HTMLModElement;
    "html:kbd": HTMLElement;
    "html:label": HTMLLabelElement;
    "html:legend": HTMLLegendElement;
    "html:li": HTMLLIElement;
    "html:link": HTMLLinkElement;
    "html:main": HTMLElement;
    "html:map": HTMLMapElement;
    "html:mark": HTMLElement;
    "html:menu": HTMLMenuElement;
    "html:meta": HTMLMetaElement;
    "html:meter": HTMLMeterElement;
    "html:nav": HTMLElement;
    "html:noscript": HTMLElement;
    "html:object": HTMLObjectElement;
    "html:ol": HTMLOListElement;
    "html:optgroup": HTMLOptGroupElement;
    "html:option": HTMLOptionElement;
    "html:output": HTMLOutputElement;
    "html:p": HTMLParagraphElement;
    "html:picture": HTMLPictureElement;
    "html:portal": HTMLUnknownElement;
    "html:pre": HTMLPreElement;
    "html:progress": HTMLProgressElement;
    "html:q": HTMLQuoteElement;
    "html:rp": HTMLElement;
    "html:rt": HTMLElement;
    "html:ruby": HTMLElement;
    "html:s": HTMLElement;
    "html:samp": HTMLElement;
    "html:script": HTMLScriptElement;
    "html:search": HTMLElement;
    "html:section": HTMLElement;
    "html:select": HTMLSelectElement;
    "html:slot": HTMLSlotElement;
    "html:small": HTMLElement;
    "html:source": HTMLSourceElement;
    "html:span": HTMLSpanElement;
    "html:strong": HTMLElement;
    "html:style": HTMLStyleElement;
    "html:sub": HTMLElement;
    "html:summary": HTMLElement;
    "html:sup": HTMLElement;
    "html:table": HTMLTableElement;
    "html:tbody": HTMLTableSectionElement;
    "html:td": HTMLTableCellElement;
    "html:template": HTMLTemplateElement;
    "html:textarea": HTMLTextAreaElement;
    "html:tfoot": HTMLTableSectionElement;
    "html:th": HTMLTableCellElement;
    "html:thead": HTMLTableSectionElement;
    "html:time": HTMLTimeElement;
    "html:title": HTMLTitleElement;
    "html:tr": HTMLTableRowElement;
    "html:track": HTMLTrackElement;
    "html:u": HTMLElement;
    "html:ul": HTMLUListElement;
    "html:var": HTMLElement;
    "html:video": HTMLVideoElement;
    "html:wbr": HTMLElement;
    "svg:a": SVGAElement;
    "svg:animate": SVGAnimateElement;
    "svg:animateMotion": SVGAnimateMotionElement;
    "svg:animateTransform": SVGAnimateTransformElement;
    "svg:circle": SVGCircleElement;
    "svg:clipPath": SVGClipPathElement;
    "svg:defs": SVGDefsElement;
    "svg:desc": SVGDescElement;
    "svg:ellipse": SVGEllipseElement;
    "svg:feBlend": SVGFEBlendElement;
    "svg:feColorMatrix": SVGFEColorMatrixElement;
    "svg:feComponentTransfer": SVGFEComponentTransferElement;
    "svg:feComposite": SVGFECompositeElement;
    "svg:feConvolveMatrix": SVGFEConvolveMatrixElement;
    "svg:feDiffuseLighting": SVGFEDiffuseLightingElement;
    "svg:feDisplacementMap": SVGFEDisplacementMapElement;
    "svg:feDistantLight": SVGFEDistantLightElement;
    "svg:feDropShadow": SVGFEDropShadowElement;
    "svg:feFlood": SVGFEFloodElement;
    "svg:feFuncA": SVGFEFuncAElement;
    "svg:feFuncB": SVGFEFuncBElement;
    "svg:feFuncG": SVGFEFuncGElement;
    "svg:feFuncR": SVGFEFuncRElement;
    "svg:feGaussianBlur": SVGFEGaussianBlurElement;
    "svg:feImage": SVGFEImageElement;
    "svg:feMerge": SVGFEMergeElement;
    "svg:feMergeNode": SVGFEMergeNodeElement;
    "svg:feMorphology": SVGFEMorphologyElement;
    "svg:feOffset": SVGFEOffsetElement;
    "svg:fePointLight": SVGFEPointLightElement;
    "svg:feSpecularLighting": SVGFESpecularLightingElement;
    "svg:feSpotLight": SVGFESpotLightElement;
    "svg:feTile": SVGFETileElement;
    "svg:feTurbulence": SVGFETurbulenceElement;
    "svg:filter": SVGFilterElement;
    "svg:foreignObject": SVGForeignObjectElement;
    "svg:g": SVGGElement;
    "svg:hatch": SVGElement;
    "svg:hatchpath": SVGElement;
    "svg:image": SVGImageElement;
    "svg:line": SVGLineElement;
    "svg:linearGradient": SVGLinearGradientElement;
    "svg:marker": SVGMarkerElement;
    "svg:mask": SVGMaskElement;
    "svg:metadata": SVGMetadataElement;
    "svg:mpath": SVGMPathElement;
    "svg:path": SVGPathElement;
    "svg:pattern": SVGPatternElement;
    "svg:polygon": SVGPolygonElement;
    "svg:polyline": SVGPolylineElement;
    "svg:radialGradient": SVGRadialGradientElement;
    "svg:rect": SVGRectElement;
    "svg:script": SVGScriptElement;
    "svg:set": SVGSetElement;
    "svg:stop": SVGStopElement;
    "svg:style": SVGStyleElement;
    "svg:svg": SVGSVGElement;
    "svg:switch": SVGSwitchElement;
    "svg:symbol": SVGSymbolElement;
    "svg:text": SVGTextElement;
    "svg:textPath": SVGTextPathElement;
    "svg:title": SVGTitleElement;
    "svg:tspan": SVGTSpanElement;
    "svg:use": SVGUseElement;
    "svg:view": SVGViewElement;
    "mathml:annotation": MathMLElement;
    "mathml:annotation-xml": MathMLElement;
    "mathml:maction": MathMLElement;
    "mathml:math": MathMLElement;
    "mathml:merror": MathMLElement;
    "mathml:mfrac": MathMLElement;
    "mathml:mi": MathMLElement;
    "mathml:mmultiscripts": MathMLElement;
    "mathml:mn": MathMLElement;
    "mathml:mo": MathMLElement;
    "mathml:mover": MathMLElement;
    "mathml:mpadded": MathMLElement;
    "mathml:mphantom": MathMLElement;
    "mathml:mprescripts": MathMLElement;
    "mathml:mroot": MathMLElement;
    "mathml:mrow": MathMLElement;
    "mathml:ms": MathMLElement;
    "mathml:mspace": MathMLElement;
    "mathml:msqrt": MathMLElement;
    "mathml:mstyle": MathMLElement;
    "mathml:msub": MathMLElement;
    "mathml:msubsup": MathMLElement;
    "mathml:msup": MathMLElement;
    "mathml:mtable": MathMLElement;
    "mathml:mtd": MathMLElement;
    "mathml:mtext": MathMLElement;
    "mathml:mtr": MathMLElement;
    "mathml:munder": MathMLElement;
    "mathml:munderover": MathMLElement;
    "mathml:semantics": MathMLElement;
};
interface CEStyleMap {
    accentColor: string;
    alignContent: string;
    alignItems: string;
    alignSelf: string;
    all: string;
    animation: string;
    animationComposition: string;
    animationDelay: string;
    animationDirection: string;
    animationDuration: string;
    animationFillMode: string;
    animationIterationCount: string;
    animationName: string;
    animationPlayState: string;
    animationTimingFunction: string;
    appearance: string;
    aspectRatio: string;
    backdropFilter: string;
    backfaceVisibility: string;
    background: string;
    backgroundAttachment: string;
    backgroundBlendMode: string;
    backgroundClip: string;
    backgroundColor: string;
    backgroundImage: string;
    backgroundOrigin: string;
    backgroundPosition: string;
    backgroundPositionX: string;
    backgroundPositionY: string;
    backgroundRepeat: string;
    backgroundSize: string;
    blockSize: string;
    border: string;
    borderBlock: string;
    borderBlockColor: string;
    borderBlockEnd: string;
    borderBlockEndColor: string;
    borderBlockEndStyle: string;
    borderBlockEndWidth: string;
    borderBlockStart: string;
    borderBlockStartColor: string;
    borderBlockStartStyle: string;
    borderBlockStartWidth: string;
    borderBlockStyle: string;
    borderBlockWidth: string;
    borderBottom: string;
    borderBottomColor: string;
    borderBottomLeftRadius: string;
    borderBottomRightRadius: string;
    borderBottomStyle: string;
    borderBottomWidth: string;
    borderCollapse: string;
    borderColor: string;
    borderEndEndRadius: string;
    borderEndStartRadius: string;
    borderImage: string;
    borderImageOutset: string;
    borderImageRepeat: string;
    borderImageSlice: string;
    borderImageSource: string;
    borderImageWidth: string;
    borderInline: string;
    borderInlineColor: string;
    borderInlineEnd: string;
    borderInlineEndColor: string;
    borderInlineEndStyle: string;
    borderInlineEndWidth: string;
    borderInlineStart: string;
    borderInlineStartColor: string;
    borderInlineStartStyle: string;
    borderInlineStartWidth: string;
    borderInlineStyle: string;
    borderInlineWidth: string;
    borderLeft: string;
    borderLeftColor: string;
    borderLeftStyle: string;
    borderLeftWidth: string;
    borderRadius: string;
    borderRight: string;
    borderRightColor: string;
    borderRightStyle: string;
    borderRightWidth: string;
    borderSpacing: string;
    borderStartEndRadius: string;
    borderStartStartRadius: string;
    borderStyle: string;
    borderTop: string;
    borderTopColor: string;
    borderTopLeftRadius: string;
    borderTopRightRadius: string;
    borderTopStyle: string;
    borderTopWidth: string;
    borderWidth: string;
    bottom: string;
    boxShadow: string;
    boxSizing: string;
    breakAfter: string;
    breakBefore: string;
    breakInside: string;
    captionSide: string;
    caretColor: string;
    clear: string;
    clip: string;
    clipPath: string;
    color: string;
    colorScheme: string;
    columnCount: string;
    columnFill: string;
    columnGap: string;
    columnRule: string;
    columnRuleColor: string;
    columnRuleStyle: string;
    columnRuleWidth: string;
    columnSpan: string;
    columnWidth: string;
    columns: string;
    contain: string;
    containIntrinsicBlockSize: string;
    containIntrinsicHeight: string;
    containIntrinsicInlineSize: string;
    containIntrinsicSize: string;
    containIntrinsicWidth: string;
    container: string;
    containerName: string;
    containerType: string;
    content: string;
    counterIncrement: string;
    counterReset: string;
    counterSet: string;
    cssFloat: string;
    cssText: string;
    cursor: string;
    direction: string;
    display: string;
    emptyCells: string;
    filter: string;
    flex: string;
    flexBasis: string;
    flexDirection: string;
    flexFlow: string;
    flexGrow: string;
    flexShrink: string;
    flexWrap: string;
    float: string;
    font: string;
    fontFamily: string;
    fontFeatureSettings: string;
    fontKerning: string;
    fontOpticalSizing: string;
    fontPalette: string;
    fontSize: string;
    fontSizeAdjust: string;
    fontStretch: string;
    fontStyle: string;
    fontSynthesis: string;
    fontSynthesisSmallCaps: string;
    fontSynthesisStyle: string;
    fontSynthesisWeight: string;
    fontVariant: string;
    fontVariantAlternates: string;
    fontVariantCaps: string;
    fontVariantEastAsian: string;
    fontVariantLigatures: string;
    fontVariantNumeric: string;
    fontVariantPosition: string;
    fontVariationSettings: string;
    fontWeight: string;
    forcedColorAdjust: string;
    gap: string;
    grid: string;
    gridArea: string;
    gridAutoColumns: string;
    gridAutoFlow: string;
    gridAutoRows: string;
    gridColumn: string;
    gridColumnEnd: string;
    gridColumnGap: string;
    gridColumnStart: string;
    gridGap: string;
    gridRow: string;
    gridRowEnd: string;
    gridRowGap: string;
    gridRowStart: string;
    gridTemplate: string;
    gridTemplateAreas: string;
    gridTemplateColumns: string;
    gridTemplateRows: string;
    height: string;
    hyphenateCharacter: string;
    hyphens: string;
    imageOrientation: string;
    imageRendering: string;
    inlineSize: string;
    inset: string;
    insetBlock: string;
    insetBlockEnd: string;
    insetBlockStart: string;
    insetInline: string;
    insetInlineEnd: string;
    insetInlineStart: string;
    isolation: string;
    justifyContent: string;
    justifyItems: string;
    justifySelf: string;
    left: string;
    letterSpacing: string;
    lineBreak: string;
    lineHeight: string;
    listStyle: string;
    listStyleImage: string;
    listStylePosition: string;
    listStyleType: string;
    margin: string;
    marginBlock: string;
    marginBlockEnd: string;
    marginBlockStart: string;
    marginBottom: string;
    marginInline: string;
    marginInlineEnd: string;
    marginInlineStart: string;
    marginLeft: string;
    marginRight: string;
    marginTop: string;
    mask: string;
    maskClip: string;
    maskComposite: string;
    maskImage: string;
    maskMode: string;
    maskOrigin: string;
    maskPosition: string;
    maskRepeat: string;
    maskSize: string;
    maskType: string;
    mathStyle: string;
    maxBlockSize: string;
    maxHeight: string;
    maxInlineSize: string;
    maxWidth: string;
    minBlockSize: string;
    minHeight: string;
    minInlineSize: string;
    minWidth: string;
    mixBlendMode: string;
    objectFit: string;
    objectPosition: string;
    offset: string;
    offsetDistance: string;
    offsetPath: string;
    offsetRotate: string;
    opacity: string;
    order: string;
    orphans: string;
    outline: string;
    outlineColor: string;
    outlineOffset: string;
    outlineStyle: string;
    outlineWidth: string;
    overflow: string;
    overflowAnchor: string;
    overflowClipMargin: string;
    overflowWrap: string;
    overflowX: string;
    overflowY: string;
    overscrollBehavior: string;
    overscrollBehaviorBlock: string;
    overscrollBehaviorInline: string;
    overscrollBehaviorX: string;
    overscrollBehaviorY: string;
    padding: string;
    paddingBlock: string;
    paddingBlockEnd: string;
    paddingBlockStart: string;
    paddingBottom: string;
    paddingInline: string;
    paddingInlineEnd: string;
    paddingInlineStart: string;
    paddingLeft: string;
    paddingRight: string;
    paddingTop: string;
    page: string;
    pageBreakAfter: string;
    pageBreakBefore: string;
    pageBreakInside: string;
    paintOrder: string;
    perspective: string;
    perspectiveOrigin: string;
    placeContent: string;
    placeItems: string;
    placeSelf: string;
    pointerEvents: string;
    position: string;
    printColorAdjust: string;
    quotes: string;
    resize: string;
    right: string;
    rotate: string;
    rowGap: string;
    rubyPosition: string;
    scale: string;
    scrollBehavior: string;
    scrollMargin: string;
    scrollMarginBlock: string;
    scrollMarginBlockEnd: string;
    scrollMarginBlockStart: string;
    scrollMarginBottom: string;
    scrollMarginInline: string;
    scrollMarginInlineEnd: string;
    scrollMarginInlineStart: string;
    scrollMarginLeft: string;
    scrollMarginRight: string;
    scrollMarginTop: string;
    scrollPadding: string;
    scrollPaddingBlock: string;
    scrollPaddingBlockEnd: string;
    scrollPaddingBlockStart: string;
    scrollPaddingBottom: string;
    scrollPaddingInline: string;
    scrollPaddingInlineEnd: string;
    scrollPaddingInlineStart: string;
    scrollPaddingLeft: string;
    scrollPaddingRight: string;
    scrollPaddingTop: string;
    scrollSnapAlign: string;
    scrollSnapStop: string;
    scrollSnapType: string;
    scrollbarGutter: string;
    shapeImageThreshold: string;
    shapeMargin: string;
    shapeOutside: string;
    shapeRendering: string;
    stopColor: string;
    stopOpacity: string;
    stroke: string;
    strokeDasharray: string;
    strokeDashoffset: string;
    strokeLinecap: string;
    strokeLinejoin: string;
    strokeMiterlimit: string;
    strokeOpacity: string;
    strokeWidth: string;
    tabSize: string;
    tableLayout: string;
    textAlign: string;
    textAlignLast: string;
    textCombineUpright: string;
    textDecoration: string;
    textDecorationColor: string;
    textDecorationLine: string;
    textDecorationSkipInk: string;
    textDecorationStyle: string;
    textDecorationThickness: string;
    textEmphasis: string;
    textEmphasisColor: string;
    textEmphasisPosition: string;
    textEmphasisStyle: string;
    textIndent: string;
    textOrientation: string;
    textOverflow: string;
    textRendering: string;
    textShadow: string;
    textTransform: string;
    textUnderlineOffset: string;
    textUnderlinePosition: string;
    top: string;
    touchAction: string;
    transform: string;
    transformBox: string;
    transformOrigin: string;
    transformStyle: string;
    transition: string;
    transitionDelay: string;
    transitionDuration: string;
    transitionProperty: string;
    transitionTimingFunction: string;
    translate: string;
    unicodeBidi: string;
    userSelect: string;
    verticalAlign: string;
    visibility: string;
    webkitAlignContent: string;
    webkitAlignItems: string;
    webkitAlignSelf: string;
    webkitAnimation: string;
    webkitAnimationDelay: string;
    webkitAnimationDirection: string;
    webkitAnimationDuration: string;
    webkitAnimationFillMode: string;
    webkitAnimationIterationCount: string;
    webkitAnimationName: string;
    webkitAnimationPlayState: string;
    webkitAnimationTimingFunction: string;
    webkitAppearance: string;
    webkitBackfaceVisibility: string;
    webkitBackgroundClip: string;
    webkitBackgroundOrigin: string;
    webkitBackgroundSize: string;
    webkitBorderBottomLeftRadius: string;
    webkitBorderBottomRightRadius: string;
    webkitBorderRadius: string;
    webkitBorderTopLeftRadius: string;
    webkitBorderTopRightRadius: string;
    webkitBoxAlign: string;
    webkitBoxFlex: string;
    webkitBoxOrdinalGroup: string;
    webkitBoxOrient: string;
    webkitBoxPack: string;
    webkitBoxShadow: string;
    webkitBoxSizing: string;
    webkitFilter: string;
    webkitFlex: string;
    webkitFlexBasis: string;
    webkitFlexDirection: string;
    webkitFlexFlow: string;
    webkitFlexGrow: string;
    webkitFlexShrink: string;
    webkitFlexWrap: string;
    webkitJustifyContent: string;
    webkitLineClamp: string;
    webkitMask: string;
    webkitMaskBoxImage: string;
    webkitMaskBoxImageOutset: string;
    webkitMaskBoxImageRepeat: string;
    webkitMaskBoxImageSlice: string;
    webkitMaskBoxImageSource: string;
    webkitMaskBoxImageWidth: string;
    webkitMaskClip: string;
    webkitMaskComposite: string;
    webkitMaskImage: string;
    webkitMaskOrigin: string;
    webkitMaskPosition: string;
    webkitMaskRepeat: string;
    webkitMaskSize: string;
    webkitOrder: string;
    webkitPerspective: string;
    webkitPerspectiveOrigin: string;
    webkitTextFillColor: string;
    webkitTextSizeAdjust: string;
    webkitTextStroke: string;
    webkitTextStrokeColor: string;
    webkitTextStrokeWidth: string;
    webkitTransform: string;
    webkitTransformOrigin: string;
    webkitTransformStyle: string;
    webkitTransition: string;
    webkitTransitionDelay: string;
    webkitTransitionDuration: string;
    webkitTransitionProperty: string;
    webkitTransitionTimingFunction: string;
    webkitUserSelect: string;
    whiteSpace: string;
    widows: string;
    width: string;
    willChange: string;
    wordBreak: string;
    wordSpacing: string;
    wordWrap: string;
    writingMode: string;
    zIndex: string;
}
type CEElements = {
    "a": { events: HTMLElementEventMap; props: { accessKey?: string; download?: string; hash?: string; host?: string; hostname?: string; href?: string; hreflang?: string; password?: string; pathname?: string; port?: string; protocol?: string; referrerPolicy?: string; rel?: string; search?: string; tabIndex?: number; target?: string; text?: string; type?: string; username?: string; }; };
    "abbr": { events: HTMLElementEventMap; props: {}; };
    "address": { events: HTMLElementEventMap; props: {}; };
    "area": { events: HTMLElementEventMap; props: { accessKey?: string; alt?: string; coords?: string; download?: string; hash?: string; host?: string; hostname?: string; href?: string; password?: string; pathname?: string; port?: string; protocol?: string; referrerPolicy?: string; rel?: string; search?: string; shape?: "rect" | "circle" | "poly" | "default"; tabIndex?: number; target?: string; username?: string; }; };
    "article": { events: HTMLElementEventMap; props: {}; };
    "aside": { events: HTMLElementEventMap; props: {}; };
    "audio": { events: HTMLMediaElementEventMap; props: { autoplay?: boolean; controls?: boolean; crossOrigin?: string; currentTime?: number; defaultMuted?: boolean; defaultPlaybackRate?: number; disableRemotePlayback?: boolean; loop?: boolean; muted?: boolean; playbackRate?: number; preload?: "none" | "metadata" | "auto" | ""; preservesPitch?: boolean; src?: string; srcObject?: MediaProvider | null; volume?: number; }; };
    "b": { events: HTMLElementEventMap; props: {}; };
    "base": { events: HTMLElementEventMap; props: { href?: string; target?: string; }; };
    "bdi": { events: HTMLElementEventMap; props: {}; };
    "bdo": { events: HTMLElementEventMap; props: {}; };
    "blockquote": { events: HTMLElementEventMap; props: { cite?: string; }; };
    "body": { events: HTMLBodyElementEventMap; props: {}; };
    "br": { events: HTMLElementEventMap; props: {}; };
    "button": { events: HTMLElementEventMap; props: { disabled?: boolean; formAction?: string; formEnctype?: string; formMethod?: string; formNoValidate?: boolean; formTarget?: string; name?: string; type?: "submit" | "reset" | "button"; value?: string; }; };
    "canvas": { events: HTMLElementEventMap; props: { height?: number; width?: number; }; };
    "caption": { events: HTMLElementEventMap; props: {}; };
    "cite": { events: HTMLElementEventMap; props: {}; };
    "code": { events: HTMLElementEventMap; props: {}; };
    "col": { events: HTMLElementEventMap; props: { span?: number; }; };
    "colgroup": { events: HTMLElementEventMap; props: { span?: number; }; };
    "data": { events: HTMLElementEventMap; props: { value?: string; }; };
    "datalist": { events: HTMLElementEventMap; props: {}; };
    "dd": { events: HTMLElementEventMap; props: {}; };
    "del": { events: HTMLElementEventMap; props: { cite?: string; dateTime?: string; }; };
    "details": { events: HTMLElementEventMap; props: { open?: boolean; }; };
    "dfn": { events: HTMLElementEventMap; props: {}; };
    "dialog": { events: HTMLElementEventMap; props: { open?: boolean; returnValue?: string; }; };
    "div": { events: HTMLElementEventMap; props: {}; };
    "dl": { events: HTMLElementEventMap; props: {}; };
    "dt": { events: HTMLElementEventMap; props: {}; };
    "em": { events: HTMLElementEventMap; props: {}; };
    "embed": { events: HTMLElementEventMap; props: { height?: string; src?: string; type?: string; width?: string; }; };
    "fieldset": { events: HTMLElementEventMap; props: { disabled?: boolean; name?: string; }; };
    "figcaption": { events: HTMLElementEventMap; props: {}; };
    "figure": { events: HTMLElementEventMap; props: {}; };
    "footer": { events: HTMLElementEventMap; props: {}; };
    "form": { events: HTMLElementEventMap; props: { acceptCharset?: string; action?: string; autocomplete?: AutoFillBase; encoding?: string; enctype?: string; method?: string; name?: string; noValidate?: boolean; rel?: string; target?: string; }; };
    "h1": { events: HTMLElementEventMap; props: {}; };
    "h2": { events: HTMLElementEventMap; props: {}; };
    "h3": { events: HTMLElementEventMap; props: {}; };
    "h4": { events: HTMLElementEventMap; props: {}; };
    "h5": { events: HTMLElementEventMap; props: {}; };
    "h6": { events: HTMLElementEventMap; props: {}; };
    "head": { events: HTMLElementEventMap; props: {}; };
    "header": { events: HTMLElementEventMap; props: {}; };
    "hgroup": { events: HTMLElementEventMap; props: {}; };
    "hr": { events: HTMLElementEventMap; props: {}; };
    "html": { events: HTMLElementEventMap; props: {}; };
    "i": { events: HTMLElementEventMap; props: {}; };
    "iframe": { events: HTMLElementEventMap; props: { allow?: string; allowFullscreen?: boolean; height?: string; loading?: string; name?: string; referrerPolicy?: ReferrerPolicy; src?: string; srcdoc?: string; width?: string; }; };
    "img": { events: HTMLElementEventMap; props: { alt?: string; crossOrigin?: string | null; decoding?: "async" | "sync" | "auto"; height?: number; isMap?: boolean; loading?: "eager" | "lazy"; referrerPolicy?: string; sizes?: string; src?: string; srcset?: string; useMap?: string; width?: number; }; };
    "input": { events: HTMLElementEventMap; props: { accept?: string; alt?: string; autocomplete?: AutoFill; capture?: string; checked?: boolean; defaultChecked?: boolean; defaultValue?: string; dirName?: string; disabled?: boolean; formAction?: string; formEnctype?: string; formMethod?: string; formNoValidate?: boolean; formTarget?: string; height?: number; indeterminate?: boolean; max?: string; maxLength?: number; min?: string; minLength?: number; multiple?: boolean; name?: string; pattern?: string; placeholder?: string; readOnly?: boolean; required?: boolean; selectionDirection?: "forward" | "backward" | "none" | null; selectionEnd?: number | null; selectionStart?: number | null; size?: number; src?: string; step?: string; type?: "button" | "checkbox" | "color" | "date" | "datetime-local" | "email" | "file" | "hidden" | "image" | "month" | "number" | "password" | "radio" | "range" | "reset" | "search" | "submit" | "tel" | "text" | "time" | "url" | "week"; value?: string; valueAsDate?: Date | null; valueAsNumber?: number; webkitdirectory?: boolean; width?: number; }; };
    "ins": { events: HTMLElementEventMap; props: { cite?: string; dateTime?: string; }; };
    "kbd": { events: HTMLElementEventMap; props: {}; };
    "label": { events: HTMLElementEventMap; props: { htmlFor?: string; }; };
    "legend": { events: HTMLElementEventMap; props: {}; };
    "li": { events: HTMLElementEventMap; props: { value?: number; }; };
    "link": { events: HTMLElementEventMap; props: { as?: string; crossOrigin?: string | null; disabled?: boolean; href?: string; hreflang?: string; imageSizes?: string; imageSrcset?: string; integrity?: string; media?: string; referrerPolicy?: string; rel?: string; type?: string; }; };
    "main": { events: HTMLElementEventMap; props: {}; };
    "map": { events: HTMLElementEventMap; props: { name?: string; }; };
    "mark": { events: HTMLElementEventMap; props: {}; };
    "menu": { events: HTMLElementEventMap; props: {}; };
    "meta": { events: HTMLElementEventMap; props: { content?: string; httpEquiv?: string; media?: string; name?: string; }; };
    "meter": { events: HTMLElementEventMap; props: { high?: number; low?: number; max?: number; min?: number; optimum?: number; value?: number; }; };
    "nav": { events: HTMLElementEventMap; props: {}; };
    "noscript": { events: HTMLElementEventMap; props: {}; };
    "object": { events: HTMLElementEventMap; props: { data?: string; height?: string; name?: string; type?: string; useMap?: string; width?: string; }; };
    "ol": { events: HTMLElementEventMap; props: { reversed?: boolean; start?: number; type?: "1" | "a" | "A" | "i" | "I"; }; };
    "optgroup": { events: HTMLElementEventMap; props: { disabled?: boolean; label?: string; }; };
    "option": { events: HTMLElementEventMap; props: { defaultSelected?: boolean; disabled?: boolean; label?: string; selected?: boolean; text?: string; value?: string; }; };
    "output": { events: HTMLElementEventMap; props: { defaultValue?: string; name?: string; value?: string; }; };
    "p": { events: HTMLElementEventMap; props: {}; };
    "picture": { events: HTMLElementEventMap; props: {}; };
    "portal": { events: HTMLElementEventMap; props: {}; };
    "pre": { events: HTMLElementEventMap; props: {}; };
    "progress": { events: HTMLElementEventMap; props: { max?: number; value?: number; }; };
    "q": { events: HTMLElementEventMap; props: { cite?: string; }; };
    "rp": { events: HTMLElementEventMap; props: {}; };
    "rt": { events: HTMLElementEventMap; props: {}; };
    "ruby": { events: HTMLElementEventMap; props: {}; };
    "s": { events: HTMLElementEventMap; props: {}; };
    "samp": { events: HTMLElementEventMap; props: {}; };
    "script": { events: HTMLElementEventMap; props: { async?: boolean; crossOrigin?: string | null; defer?: boolean; integrity?: string; noModule?: boolean; referrerPolicy?: string; src?: string; text?: string; type?: string; }; };
    "search": { events: HTMLElementEventMap; props: {}; };
    "section": { events: HTMLElementEventMap; props: {}; };
    "select": { events: HTMLElementEventMap; props: { autocomplete?: AutoFill; disabled?: boolean; length?: number; multiple?: boolean; name?: string; required?: boolean; selectedIndex?: number; size?: number; value?: string; }; };
    "slot": { events: HTMLElementEventMap; props: { name?: string; }; };
    "small": { events: HTMLElementEventMap; props: {}; };
    "source": { events: HTMLElementEventMap; props: { height?: number; media?: string; sizes?: string; src?: string; srcset?: string; type: string; width?: number; }; };
    "span": { events: HTMLElementEventMap; props: {}; };
    "strong": { events: HTMLElementEventMap; props: {}; };
    "style": { events: HTMLElementEventMap; props: { disabled?: boolean; media?: string; }; };
    "sub": { events: HTMLElementEventMap; props: {}; };
    "summary": { events: HTMLElementEventMap; props: {}; };
    "sup": { events: HTMLElementEventMap; props: {}; };
    "table": { events: HTMLElementEventMap; props: { caption?: HTMLTableCaptionElement | null; tFoot?: HTMLTableSectionElement | null; tHead?: HTMLTableSectionElement | null; }; };
    "tbody": { events: HTMLElementEventMap; props: {}; };
    "td": { events: HTMLElementEventMap; props: { abbr?: string; colSpan?: number; headers?: string; rowSpan?: number; scope?: string; }; };
    "template": { events: HTMLElementEventMap; props: {}; };
    "textarea": { events: HTMLElementEventMap; props: { autocomplete?: AutoFill; cols?: number; defaultValue?: string; dirName?: string; disabled?: boolean; maxLength?: number; minLength?: number; name?: string; placeholder?: string; readOnly?: boolean; required?: boolean; rows?: number; selectionDirection?: "forward" | "backward" | "none"; selectionEnd?: number; selectionStart?: number; value?: string; wrap?: string; }; };
    "tfoot": { events: HTMLElementEventMap; props: {}; };
    "th": { events: HTMLElementEventMap; props: { abbr?: string; colSpan?: number; headers?: string; rowSpan?: number; scope?: string; }; };
    "thead": { events: HTMLElementEventMap; props: {}; };
    "time": { events: HTMLElementEventMap; props: { dateTime?: string; }; };
    "title": { events: HTMLElementEventMap; props: { text?: string; }; };
    "tr": { events: HTMLElementEventMap; props: {}; };
    "track": { events: HTMLElementEventMap; props: { default?: boolean; kind?: string; label?: string; src?: string; srclang?: string; }; };
    "u": { events: HTMLElementEventMap; props: {}; };
    "ul": { events: HTMLElementEventMap; props: {}; };
    "var": { events: HTMLElementEventMap; props: {}; };
    "video": { events: HTMLVideoElementEventMap; props: { disablePictureInPicture?: boolean; height?: number; playsInline?: boolean; poster?: string; width?: number; }; };
    "wbr": { events: HTMLElementEventMap; props: {}; };
    "html:a": { events: HTMLElementEventMap; props: { accessKey?: string; download?: string; hash?: string; host?: string; hostname?: string; href?: string; hreflang?: string; password?: string; pathname?: string; port?: string; protocol?: string; referrerPolicy?: string; rel?: string; search?: string; tabIndex?: number; target?: string; text?: string; type?: string; username?: string; }; };
    "html:abbr": { events: HTMLElementEventMap; props: {}; };
    "html:address": { events: HTMLElementEventMap; props: {}; };
    "html:area": { events: HTMLElementEventMap; props: { accessKey?: string; alt?: string; coords?: string; download?: string; hash?: string; host?: string; hostname?: string; href?: string; password?: string; pathname?: string; port?: string; protocol?: string; referrerPolicy?: string; rel?: string; search?: string; shape?: "rect" | "circle" | "poly" | "default"; tabIndex?: number; target?: string; username?: string; }; };
    "html:article": { events: HTMLElementEventMap; props: {}; };
    "html:aside": { events: HTMLElementEventMap; props: {}; };
    "html:audio": { events: HTMLMediaElementEventMap; props: { autoplay?: boolean; controls?: boolean; crossOrigin?: string; currentTime?: number; defaultMuted?: boolean; defaultPlaybackRate?: number; disableRemotePlayback?: boolean; loop?: boolean; muted?: boolean; playbackRate?: number; preload?: "none" | "metadata" | "auto" | ""; preservesPitch?: boolean; src?: string; srcObject?: MediaProvider | null; volume?: number; }; };
    "html:b": { events: HTMLElementEventMap; props: {}; };
    "html:base": { events: HTMLElementEventMap; props: { href?: string; target?: string; }; };
    "html:bdi": { events: HTMLElementEventMap; props: {}; };
    "html:bdo": { events: HTMLElementEventMap; props: {}; };
    "html:blockquote": { events: HTMLElementEventMap; props: { cite?: string; }; };
    "html:body": { events: HTMLBodyElementEventMap; props: {}; };
    "html:br": { events: HTMLElementEventMap; props: {}; };
    "html:button": { events: HTMLElementEventMap; props: { disabled?: boolean; formAction?: string; formEnctype?: string; formMethod?: string; formNoValidate?: boolean; formTarget?: string; name?: string; type?: "submit" | "reset" | "button"; value?: string; }; };
    "html:canvas": { events: HTMLElementEventMap; props: { height?: number; width?: number; }; };
    "html:caption": { events: HTMLElementEventMap; props: {}; };
    "html:cite": { events: HTMLElementEventMap; props: {}; };
    "html:code": { events: HTMLElementEventMap; props: {}; };
    "html:col": { events: HTMLElementEventMap; props: { span?: number; }; };
    "html:colgroup": { events: HTMLElementEventMap; props: { span?: number; }; };
    "html:data": { events: HTMLElementEventMap; props: { value?: string; }; };
    "html:datalist": { events: HTMLElementEventMap; props: {}; };
    "html:dd": { events: HTMLElementEventMap; props: {}; };
    "html:del": { events: HTMLElementEventMap; props: { cite?: string; dateTime?: string; }; };
    "html:details": { events: HTMLElementEventMap; props: { open?: boolean; }; };
    "html:dfn": { events: HTMLElementEventMap; props: {}; };
    "html:dialog": { events: HTMLElementEventMap; props: { open?: boolean; returnValue?: string; }; };
    "html:div": { events: HTMLElementEventMap; props: {}; };
    "html:dl": { events: HTMLElementEventMap; props: {}; };
    "html:dt": { events: HTMLElementEventMap; props: {}; };
    "html:em": { events: HTMLElementEventMap; props: {}; };
    "html:embed": { events: HTMLElementEventMap; props: { height?: string; src?: string; type?: string; width?: string; }; };
    "html:fieldset": { events: HTMLElementEventMap; props: { disabled?: boolean; name?: string; }; };
    "html:figcaption": { events: HTMLElementEventMap; props: {}; };
    "html:figure": { events: HTMLElementEventMap; props: {}; };
    "html:footer": { events: HTMLElementEventMap; props: {}; };
    "html:form": { events: HTMLElementEventMap; props: { acceptCharset?: string; action?: string; autocomplete?: AutoFillBase; encoding?: string; enctype?: string; method?: string; name?: string; noValidate?: boolean; rel?: string; target?: string; }; };
    "html:h1": { events: HTMLElementEventMap; props: {}; };
    "html:h2": { events: HTMLElementEventMap; props: {}; };
    "html:h3": { events: HTMLElementEventMap; props: {}; };
    "html:h4": { events: HTMLElementEventMap; props: {}; };
    "html:h5": { events: HTMLElementEventMap; props: {}; };
    "html:h6": { events: HTMLElementEventMap; props: {}; };
    "html:head": { events: HTMLElementEventMap; props: {}; };
    "html:header": { events: HTMLElementEventMap; props: {}; };
    "html:hgroup": { events: HTMLElementEventMap; props: {}; };
    "html:hr": { events: HTMLElementEventMap; props: {}; };
    "html:html": { events: HTMLElementEventMap; props: {}; };
    "html:i": { events: HTMLElementEventMap; props: {}; };
    "html:iframe": { events: HTMLElementEventMap; props: { allow?: string; allowFullscreen?: boolean; height?: string; loading?: string; name?: string; referrerPolicy?: ReferrerPolicy; src?: string; srcdoc?: string; width?: string; }; };
    "html:img": { events: HTMLElementEventMap; props: { alt?: string; crossOrigin?: string | null; decoding?: "async" | "sync" | "auto"; height?: number; isMap?: boolean; loading?: "eager" | "lazy"; referrerPolicy?: string; sizes?: string; src?: string; srcset?: string; useMap?: string; width?: number; }; };
    "html:input": { events: HTMLElementEventMap; props: { accept?: string; alt?: string; autocomplete?: AutoFill; capture?: string; checked?: boolean; defaultChecked?: boolean; defaultValue?: string; dirName?: string; disabled?: boolean; formAction?: string; formEnctype?: string; formMethod?: string; formNoValidate?: boolean; formTarget?: string; height?: number; indeterminate?: boolean; max?: string; maxLength?: number; min?: string; minLength?: number; multiple?: boolean; name?: string; pattern?: string; placeholder?: string; readOnly?: boolean; required?: boolean; selectionDirection?: "forward" | "backward" | "none" | null; selectionEnd?: number | null; selectionStart?: number | null; size?: number; src?: string; step?: string; type?: "button" | "checkbox" | "color" | "date" | "datetime-local" | "email" | "file" | "hidden" | "image" | "month" | "number" | "password" | "radio" | "range" | "reset" | "search" | "submit" | "tel" | "text" | "time" | "url" | "week"; value?: string; valueAsDate?: Date | null; valueAsNumber?: number; webkitdirectory?: boolean; width?: number; }; };
    "html:ins": { events: HTMLElementEventMap; props: { cite?: string; dateTime?: string; }; };
    "html:kbd": { events: HTMLElementEventMap; props: {}; };
    "html:label": { events: HTMLElementEventMap; props: { htmlFor?: string; }; };
    "html:legend": { events: HTMLElementEventMap; props: {}; };
    "html:li": { events: HTMLElementEventMap; props: { value?: number; }; };
    "html:link": { events: HTMLElementEventMap; props: { as?: string; crossOrigin?: string | null; disabled?: boolean; href?: string; hreflang?: string; imageSizes?: string; imageSrcset?: string; integrity?: string; media?: string; referrerPolicy?: string; rel?: string; type?: string; }; };
    "html:main": { events: HTMLElementEventMap; props: {}; };
    "html:map": { events: HTMLElementEventMap; props: { name?: string; }; };
    "html:mark": { events: HTMLElementEventMap; props: {}; };
    "html:menu": { events: HTMLElementEventMap; props: {}; };
    "html:meta": { events: HTMLElementEventMap; props: { content?: string; httpEquiv?: string; media?: string; name?: string; }; };
    "html:meter": { events: HTMLElementEventMap; props: { high?: number; low?: number; max?: number; min?: number; optimum?: number; value?: number; }; };
    "html:nav": { events: HTMLElementEventMap; props: {}; };
    "html:noscript": { events: HTMLElementEventMap; props: {}; };
    "html:object": { events: HTMLElementEventMap; props: { data?: string; height?: string; name?: string; type?: string; useMap?: string; width?: string; }; };
    "html:ol": { events: HTMLElementEventMap; props: { reversed?: boolean; start?: number; type?: "1" | "a" | "A" | "i" | "I"; }; };
    "html:optgroup": { events: HTMLElementEventMap; props: { disabled?: boolean; label?: string; }; };
    "html:option": { events: HTMLElementEventMap; props: { defaultSelected?: boolean; disabled?: boolean; label?: string; selected?: boolean; text?: string; value?: string; }; };
    "html:output": { events: HTMLElementEventMap; props: { defaultValue?: string; name?: string; value?: string; }; };
    "html:p": { events: HTMLElementEventMap; props: {}; };
    "html:picture": { events: HTMLElementEventMap; props: {}; };
    "html:portal": { events: HTMLElementEventMap; props: {}; };
    "html:pre": { events: HTMLElementEventMap; props: {}; };
    "html:progress": { events: HTMLElementEventMap; props: { max?: number; value?: number; }; };
    "html:q": { events: HTMLElementEventMap; props: { cite?: string; }; };
    "html:rp": { events: HTMLElementEventMap; props: {}; };
    "html:rt": { events: HTMLElementEventMap; props: {}; };
    "html:ruby": { events: HTMLElementEventMap; props: {}; };
    "html:s": { events: HTMLElementEventMap; props: {}; };
    "html:samp": { events: HTMLElementEventMap; props: {}; };
    "html:script": { events: HTMLElementEventMap; props: { async?: boolean; crossOrigin?: string | null; defer?: boolean; integrity?: string; noModule?: boolean; referrerPolicy?: string; src?: string; text?: string; type?: string; }; };
    "html:search": { events: HTMLElementEventMap; props: {}; };
    "html:section": { events: HTMLElementEventMap; props: {}; };
    "html:select": { events: HTMLElementEventMap; props: { autocomplete?: AutoFill; disabled?: boolean; length?: number; multiple?: boolean; name?: string; required?: boolean; selectedIndex?: number; size?: number; value?: string; }; };
    "html:slot": { events: HTMLElementEventMap; props: { name?: string; }; };
    "html:small": { events: HTMLElementEventMap; props: {}; };
    "html:source": { events: HTMLElementEventMap; props: { height?: number; media?: string; sizes?: string; src?: string; srcset?: string; type: string; width?: number; }; };
    "html:span": { events: HTMLElementEventMap; props: {}; };
    "html:strong": { events: HTMLElementEventMap; props: {}; };
    "html:style": { events: HTMLElementEventMap; props: { disabled?: boolean; media?: string; }; };
    "html:sub": { events: HTMLElementEventMap; props: {}; };
    "html:summary": { events: HTMLElementEventMap; props: {}; };
    "html:sup": { events: HTMLElementEventMap; props: {}; };
    "html:table": { events: HTMLElementEventMap; props: { caption?: HTMLTableCaptionElement | null; tFoot?: HTMLTableSectionElement | null; tHead?: HTMLTableSectionElement | null; }; };
    "html:tbody": { events: HTMLElementEventMap; props: {}; };
    "html:td": { events: HTMLElementEventMap; props: { abbr?: string; colSpan?: number; headers?: string; rowSpan?: number; scope?: string; }; };
    "html:template": { events: HTMLElementEventMap; props: {}; };
    "html:textarea": { events: HTMLElementEventMap; props: { autocomplete?: AutoFill; cols?: number; defaultValue?: string; dirName?: string; disabled?: boolean; maxLength?: number; minLength?: number; name?: string; placeholder?: string; readOnly?: boolean; required?: boolean; rows?: number; selectionDirection?: "forward" | "backward" | "none"; selectionEnd?: number; selectionStart?: number; value?: string; wrap?: string; }; };
    "html:tfoot": { events: HTMLElementEventMap; props: {}; };
    "html:th": { events: HTMLElementEventMap; props: { abbr?: string; colSpan?: number; headers?: string; rowSpan?: number; scope?: string; }; };
    "html:thead": { events: HTMLElementEventMap; props: {}; };
    "html:time": { events: HTMLElementEventMap; props: { dateTime?: string; }; };
    "html:title": { events: HTMLElementEventMap; props: { text?: string; }; };
    "html:tr": { events: HTMLElementEventMap; props: {}; };
    "html:track": { events: HTMLElementEventMap; props: { default?: boolean; kind?: string; label?: string; src?: string; srclang?: string; }; };
    "html:u": { events: HTMLElementEventMap; props: {}; };
    "html:ul": { events: HTMLElementEventMap; props: {}; };
    "html:var": { events: HTMLElementEventMap; props: {}; };
    "html:video": { events: HTMLVideoElementEventMap; props: { disablePictureInPicture?: boolean; height?: number; playsInline?: boolean; poster?: string; width?: number; }; };
    "html:wbr": { events: HTMLElementEventMap; props: {}; };
    "svg:a": { events: SVGElementEventMap; props: { rel?: string; }; };
    "svg:animate": { events: SVGElementEventMap; props: {}; };
    "svg:animateMotion": { events: SVGElementEventMap; props: {}; };
    "svg:animateTransform": { events: SVGElementEventMap; props: {}; };
    "svg:circle": { events: SVGElementEventMap; props: {}; };
    "svg:clipPath": { events: SVGElementEventMap; props: {}; };
    "svg:defs": { events: SVGElementEventMap; props: {}; };
    "svg:desc": { events: SVGElementEventMap; props: {}; };
    "svg:ellipse": { events: SVGElementEventMap; props: {}; };
    "svg:feBlend": { events: SVGElementEventMap; props: {}; };
    "svg:feColorMatrix": { events: SVGElementEventMap; props: {}; };
    "svg:feComponentTransfer": { events: SVGElementEventMap; props: {}; };
    "svg:feComposite": { events: SVGElementEventMap; props: {}; };
    "svg:feConvolveMatrix": { events: SVGElementEventMap; props: {}; };
    "svg:feDiffuseLighting": { events: SVGElementEventMap; props: {}; };
    "svg:feDisplacementMap": { events: SVGElementEventMap; props: {}; };
    "svg:feDistantLight": { events: SVGElementEventMap; props: {}; };
    "svg:feDropShadow": { events: SVGElementEventMap; props: {}; };
    "svg:feFlood": { events: SVGElementEventMap; props: {}; };
    "svg:feFuncA": { events: SVGElementEventMap; props: {}; };
    "svg:feFuncB": { events: SVGElementEventMap; props: {}; };
    "svg:feFuncG": { events: SVGElementEventMap; props: {}; };
    "svg:feFuncR": { events: SVGElementEventMap; props: {}; };
    "svg:feGaussianBlur": { events: SVGElementEventMap; props: {}; };
    "svg:feImage": { events: SVGElementEventMap; props: {}; };
    "svg:feMerge": { events: SVGElementEventMap; props: {}; };
    "svg:feMergeNode": { events: SVGElementEventMap; props: {}; };
    "svg:feMorphology": { events: SVGElementEventMap; props: {}; };
    "svg:feOffset": { events: SVGElementEventMap; props: {}; };
    "svg:fePointLight": { events: SVGElementEventMap; props: {}; };
    "svg:feSpecularLighting": { events: SVGElementEventMap; props: {}; };
    "svg:feSpotLight": { events: SVGElementEventMap; props: {}; };
    "svg:feTile": { events: SVGElementEventMap; props: {}; };
    "svg:feTurbulence": { events: SVGElementEventMap; props: {}; };
    "svg:filter": { events: SVGElementEventMap; props: {}; };
    "svg:foreignObject": { events: SVGElementEventMap; props: {}; };
    "svg:g": { events: SVGElementEventMap; props: {}; };
    "svg:hatch": { events: SVGElementEventMap; props: {}; };
    "svg:hatchpath": { events: SVGElementEventMap; props: {}; };
    "svg:image": { events: SVGElementEventMap; props: {}; };
    "svg:line": { events: SVGElementEventMap; props: {}; };
    "svg:linearGradient": { events: SVGElementEventMap; props: {}; };
    "svg:marker": { events: SVGElementEventMap; props: {}; };
    "svg:mask": { events: SVGElementEventMap; props: {}; };
    "svg:metadata": { events: SVGElementEventMap; props: {}; };
    "svg:mpath": { events: SVGElementEventMap; props: {}; };
    "svg:path": { events: SVGElementEventMap; props: {}; };
    "svg:pattern": { events: SVGElementEventMap; props: {}; };
    "svg:polygon": { events: SVGElementEventMap; props: {}; };
    "svg:polyline": { events: SVGElementEventMap; props: {}; };
    "svg:radialGradient": { events: SVGElementEventMap; props: {}; };
    "svg:rect": { events: SVGElementEventMap; props: {}; };
    "svg:script": { events: SVGElementEventMap; props: {}; };
    "svg:set": { events: SVGElementEventMap; props: {}; };
    "svg:stop": { events: SVGElementEventMap; props: {}; };
    "svg:style": { events: SVGElementEventMap; props: {}; };
    "svg:svg": { events: SVGSVGElementEventMap; props: {}; };
    "svg:switch": { events: SVGElementEventMap; props: {}; };
    "svg:symbol": { events: SVGElementEventMap; props: {}; };
    "svg:text": { events: SVGElementEventMap; props: {}; };
    "svg:textPath": { events: SVGElementEventMap; props: {}; };
    "svg:title": { events: SVGElementEventMap; props: {}; };
    "svg:tspan": { events: SVGElementEventMap; props: {}; };
    "svg:use": { events: SVGElementEventMap; props: {}; };
    "svg:view": { events: SVGElementEventMap; props: {}; };
    "mathml:annotation": { events: MathMLElementEventMap; props: {}; };
    "mathml:annotation-xml": { events: MathMLElementEventMap; props: {}; };
    "mathml:maction": { events: MathMLElementEventMap; props: {}; };
    "mathml:math": { events: MathMLElementEventMap; props: {}; };
    "mathml:merror": { events: MathMLElementEventMap; props: {}; };
    "mathml:mfrac": { events: MathMLElementEventMap; props: {}; };
    "mathml:mi": { events: MathMLElementEventMap; props: {}; };
    "mathml:mmultiscripts": { events: MathMLElementEventMap; props: {}; };
    "mathml:mn": { events: MathMLElementEventMap; props: {}; };
    "mathml:mo": { events: MathMLElementEventMap; props: {}; };
    "mathml:mover": { events: MathMLElementEventMap; props: {}; };
    "mathml:mpadded": { events: MathMLElementEventMap; props: {}; };
    "mathml:mphantom": { events: MathMLElementEventMap; props: {}; };
    "mathml:mprescripts": { events: MathMLElementEventMap; props: {}; };
    "mathml:mroot": { events: MathMLElementEventMap; props: {}; };
    "mathml:mrow": { events: MathMLElementEventMap; props: {}; };
    "mathml:ms": { events: MathMLElementEventMap; props: {}; };
    "mathml:mspace": { events: MathMLElementEventMap; props: {}; };
    "mathml:msqrt": { events: MathMLElementEventMap; props: {}; };
    "mathml:mstyle": { events: MathMLElementEventMap; props: {}; };
    "mathml:msub": { events: MathMLElementEventMap; props: {}; };
    "mathml:msubsup": { events: MathMLElementEventMap; props: {}; };
    "mathml:msup": { events: MathMLElementEventMap; props: {}; };
    "mathml:mtable": { events: MathMLElementEventMap; props: {}; };
    "mathml:mtd": { events: MathMLElementEventMap; props: {}; };
    "mathml:mtext": { events: MathMLElementEventMap; props: {}; };
    "mathml:mtr": { events: MathMLElementEventMap; props: {}; };
    "mathml:munder": { events: MathMLElementEventMap; props: {}; };
    "mathml:munderover": { events: MathMLElementEventMap; props: {}; };
    "mathml:semantics": { events: MathMLElementEventMap; props: {}; };
};
const _ceNamespaces = {
    html: "http://www.w3.org/1999/xhtml",
    svg: "http://www.w3.org/2000/svg",
    mathml: "http://www.w3.org/1998/Math/MathML"
};
/**
 * @type {{[x: symbol]: string}}
 */
const _ceIds: { [x: symbol]: string; } = {};
const _ceStyles = document.head.appendChild(ce({
    name: "div"
}));
/**
 * @param {Element} el
 * @param {{[x: string | symbol]: any}} css 
 * @param {symbol} css_id 
 */
function _ceProcessCSS(el: Element, css: { [x: string | symbol]: any; }, css_id: symbol) {
    /** @type {{[x: string]: {[y: string]: string}}} */
    let t: { [x: string]: { [y: string]: string; }; } = {};
    /**
     * @param {{[x: string | symbol]: any}} o
     * @param {(string | symbol)[]} c 
     */
    function f(o: { [x: string | symbol]: any; }, c: (string | symbol)[]) {
        [
            ...Object.getOwnPropertyNames(o),
            ...Object.getOwnPropertySymbols(o)
        ].forEach((prop) => {
            let val = o[prop];
            if (typeof val == "object") {
                f(val, [...c, prop]);
            } else if (typeof val == "string") {
                if (typeof prop == "string") {
                    let s = "html";
                    let b = "";
                    let sym = css_id;
                    console.log(c);
                    c.forEach(v => {
                        if (typeof v == "symbol") {
                            s += `:has(${".ce_" + (_ceIds[sym] ? _ceIds[sym] : _ceIds[sym] = makeid(16, 10))}${b})`;
                            b = "";
                            sym = v;
                        } else {
                            b += v;
                        }
                    });
                    s += ` ${".ce_" + (_ceIds[sym] ? _ceIds[sym] : _ceIds[sym] = makeid(16, 10))}${b}`;
                    console.log(s);
                    if (t[s]) t[s][prop] = val;
                    else t[s] = {[prop]: val};
                }
            }
        });
    }
    f(css, []);
    console.log(t);
    _ceStyles.appendChild(ce({
        name: "style",
        content: Object.entries(t).map(([k, v]) => `${k} {${Object.entries(v).map(([prop, val]) => `${prop.replace(/[A-Z]/g, (match) => "-" + match.toLowerCase())}: ${val};`).join(" ")}}`).join("\n")
    }));
} 
interface BaseCEOptions {
    is?: string;
    id?: string;
    class?: string | string[];
    attrs?: { [x: string]: string | boolean; };
    dataset?: { [x: string]: any; };
    style?: Partial<CEStyleMap>;
    contentAsHTML?: boolean;
    ref?: string;
    tag?: symbol;
    css?: { [x: string | symbol]: any; };
    content?: CEOptions<keyof ElementConversions> | string | (string | CEOptions<keyof ElementConversions>)[];
}
/**
 * @template {keyof ElementConversions} T
 */
export type CEOptions<T extends keyof ElementConversions = keyof ElementConversions> = BaseCEOptions & {
    name: T; events?: {
        [x in keyof CEElements[T]['events']]?: ((this: ElementConversions[T], event: CEElements[T]['events'][x]) => void) | ((this: ElementConversions[T], event: CEElements[T]['events'][x]) => void)[];
    }; eventsOnce?: {
        [x in keyof CEElements[T]['events']]?: ((this: ElementConversions[T], event: CEElements[T]['events'][x]) => void) | ((this: ElementConversions[T], event: CEElements[T]['events'][x]) => void)[];
    };
} & CEElements[T]['props'];
/**
 * @template {keyof ElementConversions} T
 * @param {CEOptions<T>} options 
 * @param {{ [x: string]: any; }} [ref={}]
 * @returns {ElementConversions[T]}
 */
export function ce<T extends keyof ElementConversions>(options: CEOptions<T>, ref: { [x: string]: any; } = {}): ElementConversions[T] {
    let s = options.name.split(":");
    let el = s.length == 2
    //@ts-ignore
        ? document.createElementNS(_ceNamespaces[s[0]] || s[0], s[1], options.is ? {is: options.is} : undefined)
        : document.createElement(options.name, options.is ? {is: options.is} : undefined);
    if (typeof options.id == "string") el.setAttribute("id", options.id);
    if (typeof options.class == "string") el.classList.value = options.class;
    else if (Array.isArray(options.class)) el.classList.add(...options.class);
    if (typeof options.attrs == "object") Object.entries(options.attrs).forEach(([key, value]) => {
        if (typeof value == "boolean") {
            if (value) el.setAttribute(key, "");
            else el.removeAttribute(key);
        } else {
            el.setAttribute(key, value);
        }
    });
    if (typeof options.dataset == "object" && el instanceof HTMLElement) mixin(el.dataset, options.dataset);
    if (typeof options.style == "object" && (el instanceof HTMLElement || el instanceof SVGElement)) mixin(el.style, options.style, key => key.replace(/([a-z])([A-Z])/g, match => match.toLowerCase().split("").join("-")));
    if (Array.isArray(options.events)) options.events.forEach((v) => {
        el.addEventListener.apply(el, v);
    });
    else if (typeof options.events == "object") Object.entries(options.events).forEach(([key, value]) => el.addEventListener(key, value));
    if (Array.isArray(options.eventsOnce)) options.eventsOnce.forEach((v) => {
        el.addEventListener.apply(el, v);
    });
    else if (typeof options.eventsOnce == "object") Object.entries(options.eventsOnce).forEach(([key, value]) => el.addEventListener(key, value, {once: true}));
    if (typeof options.content == "string") {
        if (options.contentAsHTML) el.innerHTML += options.content;
        else el.appendChild(document.createTextNode(options.content));
    } else if (Array.isArray(options.content)) {
        let a = options.content.flat();
        for (let j = 0; j < a.length; j++) {
            let v = a[j];
            if (typeof v == "string") {
                if (options.contentAsHTML) el.innerHTML += v;
                else el.appendChild(document.createTextNode(v));
            } else {
                //@ts-ignore
                el.appendChild(ce(v, ref));
            }
        }
    }
    if (typeof options.ref == "string" && options.ref != "__proto__") ref[options.ref] = el;
    if (typeof options.css == "object" || typeof options.tag == "symbol") {
        let id = makeid(16, 10);
        let css_id = (typeof options.tag == "symbol") ? options.tag : Symbol("ce_" + id);
        if (!(css_id in _ceIds)) _ceIds[css_id] = id;
        el.classList.add("ce_" + _ceIds[css_id]);
        if (typeof options.css == "object") _ceProcessCSS(el, options.css, css_id);
    }
    mixin(el, options, [
        "name",
        "is",
        "id",
        "class",
        "attrs",
        "dataset",
        "style",
        "events",
        "eventsOnce",
        "content",
        "contentAsHTML",
        "ref",
        "css",
        "tag"
    ]);
    //@ts-ignore
    return el;
}